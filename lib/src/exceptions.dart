import 'dart:convert';
import 'dart:typed_data';

import 'event_stream/message.dart';

/// Base class for all exceptions generated by the library.
abstract class TranscribeStreamingException implements Exception {
  /// Creates a [TranscribeStreamingException] with the given message.
  const TranscribeStreamingException(this.message);

  /// The exception message.
  final String message;

  /// A string representation of this object.
  @override
  String toString() => '$runtimeType: $message';
}

/// Base class for all exceptions generated by AWS Transcribe Streaming service.
abstract class TranscribeStreamingServiceException
    extends TranscribeStreamingException {
  /// Creates a [TranscribeStreamingServiceException] with the given exception
  /// name and message.
  const TranscribeStreamingServiceException(this.exceptionName, super.message);

  /// The exception name.
  final String exceptionName;

  /// Creates an exception from AWS Transcribe Streaming service response.
  factory TranscribeStreamingServiceException.createFromResponse(
    String exceptionType,
    String contentType,
    List<int>? body,
  ) =>
      _createTranscribeStreamingServiceException(
        exceptionType,
        contentType,
        body,
      );

  /// A string representation of this object.
  @override
  String toString() => '$exceptionName: $message';
}

/// Base class for all server-side exceptions generated by AWS Transcribe
/// Streaming service.
abstract class TranscribeStreamingServiceServerException
    extends TranscribeStreamingServiceException {
  /// Creates a [TranscribeStreamingServiceServerException] with the given
  /// exception name and message.
  const TranscribeStreamingServiceServerException(super.name, super.message);
}

/// Base class for all client-side exceptions generated by AWS Transcribe
/// Streaming service.
abstract class TranscribeStreamingServiceClientException
    extends TranscribeStreamingServiceException {
  /// Creates a [TranscribeStreamingServiceClientException] with the given
  /// exception name and message.
  const TranscribeStreamingServiceClientException(super.name, super.message);
}

/// One or more arguments of [StartStreamTranscriptionRequest] were invalid.
///
/// For example, `mediaEncoding` or `languageCode` used not valid values.
/// Check the specified parameters and try your request again.
final class BadRequestException
    extends TranscribeStreamingServiceClientException {
  /// Creates a [BadRequestException] with the given message.
  const BadRequestException(String message) : super(name, message);

  /// The exception name.
  static const name = 'BadRequestException';
}

/// The provided request signature is not valid.
final class InvalidSignatureException
    extends TranscribeStreamingServiceClientException {
  /// Creates a [InvalidSignatureException] with the given message.
  const InvalidSignatureException(String message) : super(name, message);

  /// The exception name.
  static const name = 'InvalidSignatureException';
}

/// A new stream started with the same session ID.
///
/// The current stream has been terminated.
final class ConflictException
    extends TranscribeStreamingServiceClientException {
  /// Creates a [ConflictException] with the given message.
  const ConflictException(String message) : super(name, message);

  /// The exception name.
  static const name = 'ConflictException';
}

/// A problem occurred while processing the audio.
///
/// Amazon Transcribe terminated processing.
final class InternalFailureException
    extends TranscribeStreamingServiceServerException {
  /// Creates a [InternalFailureException] with the given message.
  const InternalFailureException(String message) : super(name, message);

  /// The exception name.
  static const name = 'InternalFailureException';
}

/// Your client has exceeded one of the Amazon Transcribe limits.
///
/// This is typically the audio length limit.
/// Break your audio stream into smaller chunks and try your request again.
final class LimitExceededException
    extends TranscribeStreamingServiceClientException {
  /// Creates a [LimitExceededException] with the given message.
  const LimitExceededException(String message) : super(name, message);

  /// The exception name.
  static const name = 'LimitExceededException';
}

/// The service is currently unavailable.
///
/// Try your request later.
final class ServiceUnavailableException
    extends TranscribeStreamingServiceServerException {
  /// Creates a [ServiceUnavailableException] with the given message.
  const ServiceUnavailableException(String message) : super(name, message);

  /// The exception name.
  static const name = 'ServiceUnavailableException';
}

/// The received exception has unexpected type.
final class UnexpectedExceptionTypeException
    extends TranscribeStreamingServiceException {
  /// Creates a [UnexpectedExceptionTypeException] with the given type
  /// and message.
  const UnexpectedExceptionTypeException(this.exceptionType, String message)
      : super('UnexpectedExceptionTypeException', '$exceptionType: $message');

  /// The exception type.
  final String exceptionType;
}

/// The received message has unexpected type.
final class UnexpectedMessageTypeException
    extends TranscribeStreamingException {
  /// Creates a [UnexpectedMessageTypeException] with the given message type
  /// and Event Stream message.
  const UnexpectedMessageTypeException(
    this.messageType,
    this.eventStreamMessage,
  ) : super('$messageType: $eventStreamMessage');

  /// The message type.
  final dynamic messageType;

  /// The received message.
  final EventStreamMessage eventStreamMessage;
}

/// Data interchange protocol violation.
///
/// For example, several header messages are received, or body message
/// is received before headers.
final class ProtocolException extends TranscribeStreamingException {
  /// Creates a [ProtocolException] with the given message.
  const ProtocolException(super.message);
}

TranscribeStreamingServiceException _createTranscribeStreamingServiceException(
  String exceptionType,
  String contentType,
  List<int>? body,
) {
  final responseBody = utf8.decode(body ?? Uint8List(0));
  String message = responseBody;

  if (responseBody.isNotEmpty && contentType.contains('json')) {
    final jsonResponse = json.decode(responseBody) as Map<String, dynamic>;

    if (jsonResponse.containsKey('Message')) {
      message = jsonResponse['Message'];
    } else if (jsonResponse.containsKey('message')) {
      message = jsonResponse['message'];
    }
  }

  return switch (exceptionType) {
    BadRequestException.name || '400' => BadRequestException(message),
    InvalidSignatureException.name => InvalidSignatureException(message),
    ConflictException.name || '409' => ConflictException(message),
    LimitExceededException.name || '429' => LimitExceededException(message),
    InternalFailureException.name || '500' => InternalFailureException(message),
    ServiceUnavailableException.name ||
    '503' =>
      ServiceUnavailableException(message),
    _ => UnexpectedExceptionTypeException(exceptionType, message),
  };
}
